/*******************************************************************************
 **  galag: precise re-implementation of a popular space shoot-em-up
 **  gg1-7.s (gg1-7.2c)
 **
 ** Info:
 **           6811-6814 f0 ... 9A61
 **           6815      v0 ... 9A65
 **           6816-6819 f1 ... 9A66
 **           681a      v1 ... 9A6A
 **           681b-681e f2 ... 9A6B
 **           681f      v2 ... 9A6F
 **
 ******************************************************************************/

/*
 ** header file includes
 */
#include "galag.h"

/*
 ** defines and typedefs
 */

/*
 ** extern declarations of variables defined in other files
 */
extern void pengo_sound_w(int offset, int data);

/*
 ** non-static external definitions this file or others
 */
uint8 b_9A70[0x0010]; // only because [0x09] is referenced outside
uint8 b_9AA0[0x0020]; // sound-fx count/enable


/*
 ** static external definitions in this file
 */

// variables
static uint8 b_9A00[0x0030];
static uint8 b_9A30[0x0030];
static uint8 b_9A60[0x0010]; // $10 bytes copied to 6810 (frequency & volume SFRs)
static uint16 w_9A80_04, w_9A80_06;
static uint8 b_9A82_idx; // cumulative index into d_06C3
static uint8 b_9AC0[0x0020];
static uint8 b_9A80_8[0x0003];
static uint8 b_9A70_5[0x0003];
static uint8 b_9A80_00;
static uint8 b_9A80_01;
static const uint16 dw_06A9_ndat[];
static const uint16 d_06C3[];
static const uint8 d_0703_snd_parms[];
static const uint8 d_07A6[];
static uint8 const *d_0748_p_snd_fx[];

// function prototypes
static void c_0375(void);
static void c_03F4(void);
static void c_044A(void);
static void c_04A2(void);
static void c_0550(void);
static void j_068B_close_voice_and_exit(void);

/*
 * take care of any one-time initialization here
 * everything is done in the NMI.
 */
void cpu2_init(void)
{
    // disable the NMI ... this is just here for completeness
    nmi_acknowledge_enable_cpu2 = 0; // cpu2 reset

    // wait for master to acknowledge/resume (0)

    // compute ROM checksum

    nmi_acknowledge_enable_cpu2 = 1; // cpu2 reset

    // memset(b_9A00, 0, $0100) ... clear all registers ...
    w_9A80_06 = 0;
    w_9A80_04 = 0;
    b_9A80_00 = 0;
    b_9A80_01 = 0;
}

/************************************
 *
 * NMI is called 2x per each Vblank.
 *
 ************************************/
void cpu2_NMI(void)
{
    uint16 BC;

    // memset( b_freq_vol_sfr_bufr, 0, $10 )
    BC = 0;
    while (BC < 0x0010)
    {
        b_9A60[BC++] = 0; // frequency and volume SFRs
    }

    // if ! sound-manager process disabled
    if (!b_9AA0[0x17])
    {
        r16_t HL;
        uint8 tmpA;

        // credit-in sound is triggered for all credits counted
        if (0 != b_9A70[0x09]) // if (0 != A)
        {
            b_9AA0[0x08] += b_9A70[0x09]; // add to count/enable register
            b_9A70[0x09] = 0; // reset credit-in count
        }


        // l_00D3:
        if (0 != b_9AA0[0x00]) // jr   z,l_0148 ... count/enable register, pulsing formation sound effect
        {
            tmpA = glbls9200.formatn_mv_signage;

            // _formatn_mv_signage from CPU0
            if (glbls9200.formatn_mv_signage != b_9A80_00) // jr   z,l_0102
            {
                b_9A80_00 = glbls9200.formatn_mv_signage;

                if (-1 != (sint8) b_9A80_00) // jr   z,l_00F4
                {
                    // E8 ... expanding formation
                    b_9A82_idx = 0; // ld   hl,#d_06C3
                    tmpA = 0; // xor a
                    b_9A00[0] = 0; // sound_fx_status

                    // jr   l_00FD
                }
                else // jr   z,l_00F4
                {
                    // l_00F4 ... contracting formation

                    // A == 0
                    b_9A82_idx = 8; // ld   hl,#d_06D3 ... offset 8 words
                    b_9A00[0] = 0; // sound_fx_status
                }

                // l_00FD:
                b_9A80_01 = 0; // = A ... only gets updated when b_9A80_00 == formatn_mv_signage

                // jr   l_0114

                // l_0114
                w_9A80_04 = d_06C3[ b_9A82_idx + 0 ]; // HL += 2A ... uint16[], so 2A not needed

                // ld   a,#0x1F ... $20 - $01 (1-byte increment to next word already done)
                w_9A80_06 = d_06C3[ b_9A82_idx + 16 ]; // HL += A

            }
            else // jr   z,l_0102
            {
                b_9A00[0]++; // sound_fx_status

                if (0x22 == b_9A00[0]) // jr   nz,l_0129
                {
                    b_9A00[0] = 0; // sound_fx_status

                    b_9A80_01++;

                    tmpA = b_9A80_01;

                    // l_0114
                    w_9A80_04 = d_06C3[ b_9A82_idx + tmpA + 0 ]; // HL += 2A ... uint16[], so 2A not needed

                    // ld   a,#0x1F ... $20 - $01 (1-byte increment to next word already done)
                    w_9A80_06 = d_06C3[ b_9A82_idx + tmpA + 16 ]; // HL += A
                }
            }

            // l_0129
            w_9A80_06 += w_9A80_04;

            HL.word = w_9A80_06;
            b_9A60[0x01] = HL.pair.b1; // ld   a,h

            // rrca * 4
            tmpA = ((HL.pair.b1 << 4) & 0xF0) | ((HL.pair.b1 >> 4) & 0x0F);

            // 6811-6814 f0 ... 9A61
            // 6815      v0 ... 9A65
            b_9A60[0x02] = tmpA;
            b_9A60[0x05] = 0x0A;
            b_9A70[0x00] = 0;
        }


        // l_0148: bug dive attack sound
        b_9A70[0x04] = 0x13; // bug dive attack sound
        if (b_9AA0[0x13]) // count/enable register
        {
            b_9AA0[0x13] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x13])
            {
                c_044A();
            }
        }

        // l_0165: shot sound
        b_9A70[0x04] = 0x0F; // shot sound
        if (b_9AA0[0x0F]) // count/enable register
        {
            b_9AA0[0x0F] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x0F])
            {
                c_044A();
            }
        }

        // l_0182: yellow bug hit sound
        b_9A70[0x04] = 0x03;
        if (b_9AA0[0x03]) // count/enable register
        {
            b_9AA0[0x03] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x03])
            {
                c_044A();
            }
        }

        // l_019F: red bug hit sound
        b_9A70[0x04] = 0x02;
        if (b_9AA0[0x02]) // count/enable register
        {
            b_9AA0[0x02] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x02])
            {
                c_044A();
            }
        }

        // l_01BC: green boss hit sound
        b_9A70[0x04] = 0x04;
        if (b_9AA0[0x04]) // count/enable register
        {
            b_9AA0[0x04] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x04])
            {
                c_044A();
            }
        }

        // l_01D9: blue boss hit sound
        b_9A70[0x04] = 0x01;
        if (b_9AA0[0x01]) // count/enable register
        {
            b_9AA0[0x01] = 0;
            c_03F4();
        }
        else
        {
            if (b_9AC0[0x01])
            {
                c_044A();
            }
        }

        // l_0266: $9 .. $7
        if (b_9AA0[0x09]) // count/enable register
        {
            b_9A70[0x04] = 0x09;
            c_0375();
        }
        else
        {
            b_9AC0[0x09] = 0; // clear the active flag
        }

        // l_0279: shot your ship!
        if (b_9AA0[0x07]) // count/enable register ... shot your ship!
        {
            b_9A70[0x04] = 0x07;
            c_04A2();
        }

        // l_0287: "rescued ship" theme
        if (b_9AA0[0x11]) // count/enable register ... "rescued ship" theme
        {
            b_9A70[0x04] = 0x11;
            c_0375();
        }
        else
        {
            b_9AC0[0x11] = 0; // clear the active flag
        }

        // l_029A: challenge stage intro music
        if (b_9AA0[0x0D]) // count/enable register ... start challenge stage music
        {
            b_9A70[0x04] = 0x0D;
            c_04A2();
        }

        // l_02A8: challenge stage default melody
        if (b_9AA0[0x0E]) // count/enable register ... challenge stage default melody
        {
            b_9A70[0x04] = 0x0E;
            c_04A2();
        }

        // l_02B6: challenge stage default melody
        if (b_9AA0[0x0E]) // count/enable register ... challenge stage default melody
        {
            b_9A60[0x0A] = 9; // voice 1 volume
            b_9A60[0x0F] = 6; // voice 2 volume
        }

        // l_02C6: challenge stage perfect melody
        if (b_9AA0[0x14]) // count/enable register ... challenge stage perfect melody
        {
            b_9A70[0x04] = 0x14;
            c_04A2();
        }

        // l_02D4: stage tokens "clicks"
        if (b_9AA0[0x15]) // count/enable register ... stage tokens "clicks"
        {
            b_9A70[0x04] = 0x15;
            c_04A2();
        }

        // l_02E2: new spare ship added
        if (b_9AA0[0x0A]) // count/enable register ... new spare ship added
        {
            b_9A70[0x04] = 0x0A;
            c_04A2();
        }

        // l_02F0: start of game theme
        if (b_9AA0[0x0B]) // count/enable register ... start of game theme
        {
            b_9A70[0x04] = 0x0B;
            c_04A2();
        }

        // l_02FE: ?
        if (b_9AA0[0x10]) //  count/enable register ... hi-score dialog?
        {
            b_9A70[0x04] = 0x10;
            c_0375();
        }
        else
        {
            b_9AC0[0x10] = 0; // clear the active flag
        }

        // l_0311: hi-score dialog?
        if (b_9AA0[0x0C]) //  count/enable register ... hi-score dialog?
        {
            b_9A70[0x04] = 0x0C;
            c_04A2();
        }

        // l_031F: hi-score dialog?
        if (b_9AA0[0x16]) //  count/enable register ... hi-score dialog?
        {
            b_9A70[0x04] = 0x16;
            c_04A2();
        }

        // l_032D: coin sound
        if (b_9AA0[0x08]) // count/enable register ... coin sound
        {
            b_9A70[0x04] = 8;
            c_04A2();
        }
    }
    else // l_033D_clear_all ... snd_disable != 0
    {
        // l_033D_clear_all

        // memset( snd_cnt_enable, 0, $16 ) .. don't clear [$16], [$17], [$18]
        for (BC = 0; BC < 0x16; BC++)
        {
            b_9AA0[BC] = 0;
        }
        // memset( snd_active_flag, 0, $17 ) ...  [$16] should be highest one used
        for (BC = 0; BC < 0x17; BC++)
        {
            b_9AC0[BC] = 0;
        }
    }


    // j_0357_set_SFRs:

    // The SFRs could be written directly, but the _sound_w takes care of
    // properly masking the lower nibble.
    for (BC = 0; BC < 0x10; BC++)
    {
        pengo_sound_w(0x10 + BC, b_9A60[BC]); // frequency and volume SFRs
    }

    // set the sound voice waveforms
    pengo_sound_w(0x05, b_9A70[0]); // voice 0 wave
    pengo_sound_w(0x0A, b_9A70[1]); // voice 1 wave
    pengo_sound_w(0x0F, b_9A70[2]); // voice 2 wave

    return;
}

/*
 *
 */
static void c_0375(void)
{
    uint16 BC;
    uint8 A, B;

    // memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
    for (BC = 0; BC < 3; BC++)
    {
        b_9A70_5[ BC ] = d_0703_snd_parms[ b_9A70[0x04] * 3 + BC ];
    }

    // if challenge stage default melody
    if (0x0E == b_9A70[0x04])
    {
        if (0 == b_9A30[0x1C]) // data_index
        {
            b_9A70_5[0x01] = 1;
        }
        else if (1 == b_9A30[0x1C] || 0 == b_9A30[0x1D]) // data_index
        {
            b_9A70_5[0x01] = 2;
        }
    }

    // l_03A6: now we are checking active flags for some reason,,,,
    if (0 == b_9AC0[ b_9A70[0x04] ])
    {
        b_9AC0[ b_9A70[0x04] ]++;

        B = b_9A70_5[ 1 ]; // snd_parms_set.count

        // memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
        for (A = 0; A < B; A++)
        {
            b_9A30[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
        }

        // memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
        for (A = 0; A < B; A++)
        {
            b_9A00[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
        }
    }

    // j_03CD:
    while (1) // snd_parms_set.count
    {
        c_0550();

        b_9A70_5[ 1 ]--; // snd_parms_set.count

        if (0 == b_9A70_5[ 1 ]) // number of data pairs
            break;

        b_9A70_5[ 0 ]++; // snd_parms_set.idx++
        b_9A70_5[ 2 ]++; // voice_select++
    } // l_03CD_while


    // l_03E0:
    if (0 == b_9A70[0x08])
        return;

    b_9A70[0x08] = 0;

    // clear the sound_active flag for this one
    b_9AC0[ b_9A70[0x04] ] = 0; // b_9AC0[ actv_snd_idx ] = 0

    /*
     exactly the same as c_04A2 until here ...
     update the count/enable register for certain sound-effects
     */
    return;
}

/*
 *
 */
static void c_03F4(void)
{
    uint16 BC;
    uint8 A, B;

    // on this one we increment the Active flag
    b_9AC0[ b_9A70[0x04] ]++;

    // same as c_04A2 here
    // memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
    for (BC = 0; BC < 3; BC++)
    {
        b_9A70_5[ BC ] = d_0703_snd_parms[ b_9A70[0x04] * 3 + BC ];
    }

    // if challenge stage default melody
    if (0x0E == b_9A70[0x04])
    {
        if (0 == b_9A30[0x1C]) // data_index
        {
            b_9A70_5[0x01] = 1;
        }
        else if (1 == b_9A30[0x1C] || 0 == b_9A30[0x1D]) // data_index
        {
            b_9A70_5[0x01] = 2;
        }
    }

    // here we don't check the flags...

    // l_042E:
    B = b_9A70_5[ 1 ]; // snd_parms_set.count

    // memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
    for (A = 0; A < B; A++)
    {
        b_9A30[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
    }

    // memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
    for (A = 0; A < B; A++)
    {
        b_9A00[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
    }

    // here is where c_0550 is called....
    /*
       jr   j_047B
     */
    // j_047B: the rest of this is simply copied in from j_047B
    while (1) // snd_parms_set.count
    {
        c_0550();

        b_9A70_5[ 1 ]--; // snd_parms_set.count

        if (0 == b_9A70_5[ 1 ]) // number of data pairs
            break;

        b_9A70_5[ 0 ]++; // snd_parms_set.idx++
        b_9A70_5[ 2 ]++; // voice_select++
    } // jr   l_04FA_while

    // l_048E:
    if (0 == b_9A70[0x08])
        return;

    b_9A70[0x08] = 0;

    // clear the sound_active flag for this one
    b_9AC0[ b_9A70[0x04] ] = 0; // b_9AC0[ actv_snd_idx ] = 0

    return;
}

/*
 *
 */
static void c_044A(void)
{
    uint16 BC;

    // memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
    for (BC = 0; BC < 3; BC++)
    {
        b_9A70_5[ BC ] = d_0703_snd_parms[ b_9A70[0x04] * 3 + BC ];
    }

    // if challenge stage default melody
    if (0x0E == b_9A70[0x04])
    {
        if (0 == b_9A30[0x1C]) // data_index
        {
            b_9A70_5[0x01] = 1;
        }
        else if (1 == b_9A30[0x1C] || 0 == b_9A30[0x1D]) // data_index
        {
            b_9A70_5[0x01] = 2;
        }
    }

    // j_047B:
    while (1) // snd_parms_set.count
    {
        c_0550();

        b_9A70_5[ 1 ]--; // snd_parms_set.count

        if (0 == b_9A70_5[ 1 ]) // number of data pairs
            break;

        b_9A70_5[ 0 ]++; // snd_parms_set.idx++
        b_9A70_5[ 2 ]++; // voice_select++
    } // jr   l_04FA_while

    // l_048E:
    if (0 == b_9A70[0x08])
        return;

    b_9A70[0x08] = 0;

    // clear the sound_active flag for this one
    b_9AC0[ b_9A70[0x04] ] = 0; // b_9AC0[ actv_snd_idx ] = 0

    return;
}

/*
 *
 */
static void c_04A2(void)
{
    uint8 *HL;
    uint16 BC;
    uint8 A, B;

    // memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
    for (BC = 0; BC < 3; BC++)
    {
        b_9A70_5[ BC ] = d_0703_snd_parms[ b_9A70[0x04] * 3 + BC ];
    }

    // if challenge stage default melody
    if (0x0E == b_9A70[0x04])
    {
        if (0 == b_9A30[0x1C]) // data_index
        {
            b_9A70_5[0x01] = 1;
        }
        else if (1 == b_9A30[0x1C] || 0 == b_9A30[0x1D]) // data_index
        {
            b_9A70_5[0x01] = 2;
        }
    }

    // l_04D3: now we are checking active flags for some reason,,,,
    if (0 == b_9AC0[ b_9A70 [0x04] ])
    {
        b_9AC0[ b_9A70[0x04] ]++;

        B = b_9A70_5[ 1 ]; // snd_parms_set.count

        // memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
        for (A = 0; A < B; A++)
        {
            b_9A30[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
        }

        // memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
        for (A = 0; A < B; A++)
        {
            b_9A00[ A + b_9A70_5[ 0 ] ] = 0; // snd_parms_set.idx
        }
    }

    // j_04FA:
    while (1) // snd_parms_set.count
    {
        c_0550();

        b_9A70_5[ 1 ]--; // snd_parms_set.count

        if (0 == b_9A70_5[ 1 ]) // number of data pairs
            break;

        b_9A70_5[ 0 ]++; // snd_parms_set.idx++
        b_9A70_5[ 2 ]++; // voice_select++
    } // jr   l_04FA_while

    // l_050D:
    if (0 == b_9A70[0x08])
        return;

    b_9A70[0x08] = 0;

    // clear the sound_active flag for this one
    b_9AC0[ b_9A70[0x04] ] = 0; // b_9AC0[ actv_snd_idx ] = 0

    /*
     exactly the same as c_0375 until here ...
     update the count/enable register for certain sound-effects
     */

    HL = &b_9AA0[ b_9A70[0x04] ]; // b_9AA0[ actv_snd_idx ] ... count/enable register

    // switch( actv_snd_idx )
    if (8 == b_9A70[0x04]) // actv_snd_idx
    {
        // l_053A:
        (*HL)--; // b_9AA0[actv_snd_idx] ... count/enable register, coin sound
        return;
    }
    else if (0x0C == b_9A70[0x04])
    {
        // l_053C
        (*HL)--;
        if (0 != *(HL))
        {
            if (0 == (*(HL) & 0x01))
            {
                return;
            }
        }
        // l_0542
        b_9AA0[0x16] = 1; // count / enable register, hi - score dialog ?
        return;
    }
    else if (0x14 == b_9A70[0x04])
    {
        // l_0548:
        *HL = 0; // b_9AA0[ actv_snd_idx ]
        b_9AA0[0x13] = 1; // count/enable register, bug dive attack sound
        return;
    }

    *HL = 0; // b_9AA0[actv_snd_idx]

    return; // end 'call _04A2'
}

/*
 *
 */
static void c_0550(void)
{
    uint8 const *pHLtmp;
    uint8 *HL;
    uint8 *DE;
    uint8 const *p_snd_fx_data_9A70_0A;
    int tmp_060D = 0;
    uint16 BC, tmp16DE, tmp16HL;
    uint8 A, B;


    b_9A00[ b_9A70_5[ 0 ] ]++; // b_9A00[ snd_parms_set.idx ]++

    /*
     get a pointer to the sound effect data structure from the table
     copy the header info (first 3 bytes)
     */
    pHLtmp = d_0748_p_snd_fx[ b_9A70_5[ 0 ] ];

    for (BC = 0; BC < 3; BC++)
    {
        b_9A80_8[ BC ] = *pHLtmp;
        pHLtmp++;
    }

    // 9A30[snd_parms_set.idx] holds the offset (n) from snd_fx_data[3]

    A = b_9A30[ b_9A70_5[ 0 ] ];

    p_snd_fx_data_9A70_0A = pHLtmp + A; // save the pointer ... snd_fx_data[ 3 + n ]


    if (0xFF == *p_snd_fx_data_9A70_0A)
    {
        j_068B_close_voice_and_exit();
        return;
    }

    // reload the current pointer to sound-effect data
    // lo-nibble of sound-effect data is index into note-data
    BC = dw_06A9_ndat[ *p_snd_fx_data_9A70_0A & 0x0F ]; // word pointer into note-data

    // use the hi-nibble of sound-effect data ...
    A = (*p_snd_fx_data_9A70_0A >> 4) & 0x0F;

    // ... raised to power-of-two as divisor if non-zero:
    while (0 != A)
    {
        BC >>= 1;
        A--;
    }

    // l_059F:
    switch (b_9A70_5[ 2 ]) // voice_select
    {
    case 2: // freq 2
        HL = &b_9A60[0x0B];
        break;
    case 1: // freq 1
        HL = &b_9A60[0x06];
        break;
    case 0: // freq 0
        HL = &b_9A60[0x01];
        break;
    }

    // shift out 4 nibbles from lsn to msn (only low 4-bits of each register)
    // BC = dw_06A9_ndat[n] divided by hi-nibble of sound-effect ^ 2
    *HL = BC;
    *(HL + 1) = BC >> 4;
    *(HL + 2) = BC >> 8;
    *(HL + 3) = BC >> 12;

    // voice_select
    switch (b_9A70_5[2])
    {
    case 2:
        DE = &b_9A60[0x0F]; // vol 2
        break;
    case 1:
        DE = &b_9A60[0x0A]; // vol 1
        break;
    case 0:
        DE = &b_9A60[0x05]; // vol 0
        break;
    }

    if (0x0C == *p_snd_fx_data_9A70_0A)
    {
        // jr   z,l_0628
        // l_0628:
        A = 0; // xor  a
        //jr   l_062D
    }
    else if (0 == b_9A80_8[0])
    {
        // jr   z,l_060D
        tmp_060D = 1;
    }
    else if (1 == b_9A80_8[0])
    {
        // jr   z,l_05FD
        // l_05FD:
        A = b_9A00[ b_9A70_5[ 0 ] ];

        if (A >= 6)
        {
            // jr   nc,l_060D
            tmp_060D = 1;
        }
        else
        {
            A += A;
            // jr   l_062D
        }
    }
    else
    {
        // 05ED
        if (b_9A00[ b_9A70_5[ 0 ] ] >= 6)
        {
            // jr   nc,l_060D
            tmp_060D = 1;
        }
        else
        {
            A = ~A; //  cpl
            //  jr   l_062D
        }
    }

    // l_060D:
    if (tmp_060D)
    {
        A = b_9A80_8[1];
        if (0 == A)
        {
            // jr   z,l_062B
            //l_062B:
            A = 0x0A;
            // l_062D:
        }
        else
        {
            B = A;
            A = b_9A00[ b_9A70_5[ 0 ] ];
            if (A < B)
            {
                // jr   c,l_062B
                //l_062B:
                A = 0x0A;
                // l_062D:
            }
            else
            {
                // l_0628:
                A -= B;
                if (A > 0x0A)
                {
                    // jr   nc,l_0628
                    // l_0628:
                    A = 0; // xor  a
                }
                else
                {
                    A = -A; // neg
                    //jr   l_062D
                }
            }
        }
    } // tmp_060D


    // l_062D
    *DE = A; // volume ... (9A65 etc)

    // b_9A70_wave_select[ voice_select ]
    b_9A70[ b_9A70_5[ 2 ] ] = b_9A80_8[ 2 ]; // sound_effect_parms.wave


    // get base multiplier
    A = d_07A6[ b_9A70[ 4 ] ]; // base_multipliers[ actv_snd_idx  ]

    // Multiplier = second byte of sound fx data pair
    tmp16DE = *(p_snd_fx_data_9A70_0A + 1);

    // Multiply by weighting each bit of the base by the multiplier in E and adding.
    tmp16HL = 0;
    B = 8;

    // l_064E_do_while
    do
    {
        if (A & 0x01)
        {
            tmp16HL += tmp16DE;
        }
        A >>= 1;
        tmp16DE <<= 1;
    }
    while (--B > 0);

    B = tmp16HL;

    // return if count is elapsed
    if (B != b_9A00[ b_9A70_5[ 0 ] ]) return; // sound_fx_status[ snd_parms_set.idx ]

    // update the data pointer and count registers
    b_9A30[ b_9A70_5[ 0 ] ] += 2; // snd_fx_dat_idx[]
    b_9A00[ b_9A70_5[ 0 ] ] = 0; // sound_fx_status[]

    return;
}

/*
 *
 */
static void j_068B_close_voice_and_exit(void)
{
    uint8 A;

    A = b_9A70[0x07];
    if (!A)
    {
        // jr   z,l_069E
        b_9A60[0x05] = 0;
        b_9A70[0x08] = 1;
        return;
    }

    A--;
    if (!A)
    {
        // jr   z,l_0699
        b_9A60[0x0A] = 0;
        b_9A70[0x08] = 1;
        return;
    }

    b_9A60[0x0F] = 0;
    b_9A70[0x08] = 1;
}


/*
 Note frequency data:
 Frequency values are indexed by lower-nibble of sound effect data, then
 divided down by taking the hi-nibble of sound effect data raised to 2 as the
 divisor.
 */
static const uint16 dw_06A9_ndat[] = {
    0x8150, // $00
    0x8900, // $01
    0x9126, // $02
    0x99C8, // $03
    0xA2EC, // $04
    0xAC9D, // $05
    0xB6E0, // $06
    0xC1C0, // $07
    0xCD45, // $08
    0xD97A, // $09
    0xE669, // $0A
    0xF41C, // $0B
    0x0000 // $0C
};

/*
 ** Data for "pulsating" sound effect
 */
static const uint16 d_06C3[] = {
    0x0130, 0x0168, 0x0136, 0x01A8,
    0x0168, 0x0200, 0x01AC, 0x0208,

    0xFE00, 0xFE58, 0xFE08, 0xFE98,
    0xFE58, 0xFED0, 0xFE98, 0xFED6,

    0x5B00, 0x6C00, 0x5B00, 0x7E00,
    0x6C00, 0x9700, 0x8100, 0x9900,

    0xD900, 0xB600, 0xD900, 0x9700,
    0xB600, 0x7E00, 0x9900, 0x8100
};

/*
 */
static const uint8 d_0703_snd_parms[] = {
    0x00, 0x01, 0x00,
    0x01, 0x01, 0x01,
    0x02, 0x01, 0x01,
    0x03, 0x01, 0x01,
    0x04, 0x01, 0x01,
    0x05, 0x01, 0x00,
    0x06, 0x01, 0x00,
    0x20, 0x03, 0x00,
    0x0A, 0x03, 0x00,
    0x0D, 0x03, 0x00,
    0x07, 0x03, 0x00,
    0x13, 0x03, 0x00,
    0x16, 0x03, 0x00,
    0x19, 0x03, 0x00,
    0x1C, 0x03, 0x00,
    0x1F, 0x01, 0x02,
    0x2C, 0x03, 0x00,
    0x10, 0x03, 0x00,
    0x23, 0x01, 0x00,
    0x24, 0x01, 0x00,
    0x25, 0x03, 0x00,
    0x28, 0x01, 0x00,
    0x29, 0x03, 0x00,
};

// forward declarations for pointers in p_snd_fx
const uint8 d_07BD[];
const uint8 d_07BE[];
const uint8 d_07F2[];
const uint8 d_0814[];
const uint8 d_085E[];
const uint8 d_0878[];
const uint8 d_088C[];
const uint8 d_08A0[];
const uint8 d_08EC[];
const uint8 d_0936[];
const uint8 d_0966[];
const uint8 d_0978[];
const uint8 d_098A[];
const uint8 d_099C[];
const uint8 d_09AE[];
const uint8 d_09C0[];
const uint8 d_09D2[];
const uint8 d_09E2[];
const uint8 d_09F2[];
const uint8 d_0A02[];
const uint8 d_0A46[];
const uint8 d_0A8A[];
const uint8 d_0AB6[];
const uint8 d_0AFA[];
const uint8 d_0B3E[];
const uint8 d_0B6A[];
const uint8 d_0BA0[];
const uint8 d_0BD6[];
const uint8 d_0BF4[];
const uint8 d_0C08[];
const uint8 d_0C5C[];
const uint8 d_0CE0[];
const uint8 d_0CEA[];
const uint8 d_0D2E[];
const uint8 d_0D38[];
const uint8 d_0D54[];
const uint8 d_0D5E[];
const uint8 d_0D6C[];
const uint8 d_0DE0[];
const uint8 d_0E5C[];
const uint8 d_0E9E[];
const uint8 d_0EDA[];
const uint8 d_0F16[];

/*
 Pointers into sound effect data tables (d_07BD and beyond) loaded by c_0550
 Pointer selection by b_9A70[5] ... snd_parms_set.idx
 Ordering of these elements is used also to index byte tables at 9A00 and 9A30.
 */
static uint8 const *d_0748_p_snd_fx[] = {
    d_07BD, //  0
    d_0814, //  1
    d_07F2, //  2
    d_07BE, //  3
    d_085E, //  4
    d_0878, //  5
    d_088C, //  6
    d_09D2, //  7
    d_09E2, //  8
    d_09F2, //  9
    d_099C, //  10
    d_09AE, //  11
    d_09C0, //  12
    d_0A02, //  13
    d_0A46, //  14
    d_0A8A, //  15
    d_0AB6, //  16
    d_0AFA, //  17
    d_0B3E, //  18
    d_08A0, //  19
    d_08EC, //  20
    d_0936, //  21
    d_0C5C, //  22
    d_0CEA, //  23
    d_0D38, //  24
    d_0966, //  25
    d_0978, //  26
    d_098A, //  27
    d_08A0, //  28
    d_08A0, //  29
    d_08A0, //  30
    d_0C08, //  31
    d_0B6A, //  32
    d_0BA0, //  33
    d_0BD6, //  34
    d_0BF4, //  35
    d_0C08, //  36
    d_0D6C, //  37
    d_0DE0, //  38
    d_0E5C, //  39
    d_0D5E, //  40
    d_0CE0, //  41
    d_0D2E, //  42
    d_0D54, //  43
    d_0E9E, //  44
    d_0EDA, //  45
    d_0F16, //  46
};

// indexed by active sound index
static const uint8 d_07A6[] = {
    0x04, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x0A, 0x07, 0x0C, 0x0B, 0x04, 0x0A, 0x0D, 0x04, 0x01,
    0x04, 0x0C, 0x02, 0x06, 0x05, 0x02, 0x0A
};

// sound effect data:
//  header-info, stored at 9A80_8[]
//        [0]
//        [1]
//        [2]: wave table index
//  byte_pairs * n
//        [0]: lo-nibble is index into frequency tbl
//             hi-nibble^2 = divisor to note frequency
//        [1]
//        [n] 0xFF

const uint8 d_07BD[] = {
    0xFF
};

const uint8 d_07BE[] = {
    0x00, 0x00, 0x06,
    0x71, 0x01, 0x72, 0x01, 0x73, 0x01, 0x75, 0x01,
    0x74, 0x01, 0x73, 0x01, 0x72, 0x01, 0x71, 0x01, 0x70, 0x01, 0x8B, 0x01, 0x8A, 0x01, 0x0C, 0x04,
    0x86, 0x01, 0x87, 0x01, 0x88, 0x01, 0x89, 0x01, 0x8A, 0x01, 0x89, 0x01, 0x88, 0x01, 0x87, 0x01,
    0x86, 0x01, 0x85, 0x01, 0x84, 0x01, 0x83, 0x01, 0xFF
};

const uint8 d_07F2[] = {
    0x00, 0x00, 0x04, 0x88, 0x01, 0x8A, 0x01, 0x70, 0x01, 0x71, 0x01, 0x73, 0x01, 0x75, 0x01, 0x77,
    0x01, 0x78, 0x01, 0x0C, 0x06, 0x74, 0x01, 0x73, 0x01, 0x72, 0x01, 0x71, 0x01, 0x70, 0x01, 0x8B,
    0x01, 0xFF
};

const uint8 d_0814[] = {
    0x00, 0x00, 0x07,
    0x89, 0x01, 0x8A, 0x01, 0x8B, 0x01, 0x0C, 0x01, 0x70, 0x01, 0x71, 0x01, 0x72, 0x01, 0x0C, 0x01, 0x73, 0x01,
    0x74, 0x01, 0x75, 0x01, 0x0C, 0x03, 0x8B, 0x01, 0x70, 0x01, 0x71, 0x01, 0x0C, 0x01, 0x72, 0x01,
    0x73, 0x01, 0x74, 0x01, 0x0C, 0x01, 0x75, 0x01, 0x76, 0x01, 0x77, 0x01, 0x0C, 0x03, 0x71, 0x01,
    0x72, 0x01, 0x73, 0x01, 0x0C, 0x01, 0x74, 0x01, 0x75, 0x01, 0x76, 0x01, 0x0C, 0x01, 0x77, 0x01,
    0x78, 0x01, 0x79, 0x01, 0xFF
};

const uint8 d_085E[] = {
    0x00, 0x00, 0x05, 0x71, 0x01, 0x72, 0x01, 0x73, 0x01, 0x0C, 0x01,
    0x74, 0x01, 0x75, 0x01, 0x76, 0x01, 0x0C, 0x01, 0x77, 0x01, 0x78, 0x01, 0x79, 0x01, 0xFF
};

const uint8 d_0878[] = {
    0x00, 0x00, 0x04, 0x61, 0x01, 0x7A, 0x01, 0x60, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x76, 0x01, 0x78,
    0x01, 0x75, 0x01, 0xFF
};

const uint8 d_088C[] = {
    0x00, 0x00, 0x00, 0x76, 0x01, 0x79, 0x01, 0x60, 0x01, 0x63, 0x01, 0x66, 0x01,
    0x63, 0x01, 0x60, 0x01, 0x79, 0x01, 0xFF
};

const uint8 d_08A0[] = {
    0x00, 0x00, 0x07, 0x81, 0x08, 0x81, 0x01, 0x86, 0x03,
    0x88, 0x09, 0x8B, 0x03, 0x8A, 0x09, 0x86, 0x03, 0x88, 0x09, 0x73, 0x03, 0x71, 0x09, 0x86, 0x03,
    0x88, 0x09, 0x8B, 0x03, 0x8A, 0x09, 0x86, 0x03, 0x71, 0x09, 0x75, 0x03, 0x76, 0x09, 0x74, 0x03,
    0x72, 0x09, 0x71, 0x03, 0x8B, 0x09, 0x89, 0x03, 0x88, 0x09, 0x84, 0x03, 0x74, 0x09, 0x76, 0x03,
    0x74, 0x09, 0x71, 0x03, 0x73, 0x04, 0x8B, 0x04, 0x88, 0x04, 0x71, 0x04, 0x8A, 0x04, 0x88, 0x04,
    0x0C, 0x10, 0xFF
};

const uint8 d_08EC[] = {
    0x00, 0x00, 0x06, 0x8A, 0x09, 0x81, 0x03, 0x88, 0x09, 0x83, 0x03, 0x86, 0x09,
    0x81, 0x03, 0x83, 0x09, 0x85, 0x03, 0x8A, 0x09, 0x81, 0x03, 0x88, 0x09, 0x83, 0x03, 0x86, 0x09,
    0x81, 0x03, 0x88, 0x09, 0x71, 0x03, 0x72, 0x09, 0x71, 0x03, 0x8B, 0x09, 0x89, 0x03, 0x88, 0x09,
    0x86, 0x03, 0x84, 0x09, 0x88, 0x03, 0x89, 0x09, 0x8B, 0x03, 0x89, 0x09, 0x86, 0x03, 0x8B, 0x04,
    0x88, 0x04, 0x83, 0x04, 0x88, 0x04, 0x85, 0x04, 0x83, 0x04, 0x0C, 0x10, 0xFF
};

const uint8 d_0936[] = {
    0x00, 0x00, 0x07, 0x81, 0x0C, 0x83, 0x09, 0x86, 0x03, 0x85, 0x0C, 0x81, 0x0C, 0x86, 0x0C, 0x88, 0x09, 0x8B, 0x03,
    0x8A, 0x0C, 0x88, 0x0C, 0x89, 0x0C, 0x88, 0x09, 0x86, 0x03, 0x84, 0x0C, 0x89, 0x0C, 0x74, 0x0C,
    0x71, 0x09, 0x89, 0x03, 0x88, 0x0C, 0x71, 0x09, 0x8A, 0x03, 0x0C, 0x10, 0xFF
};

const uint8 d_0966[] = {
    0x02, 0x00, 0x03,
    0x78, 0x02, 0x0C, 0x01, 0x78, 0x01, 0x79, 0x01, 0x7B, 0x01, 0x61, 0x03, 0x0C, 0x03, 0xFF
};

const uint8 d_0978[] = {
    0x02, 0x00, 0x03, 0x73, 0x02, 0x0C, 0x01, 0x73, 0x01, 0x74, 0x01, 0x76, 0x01, 0x78, 0x03, 0x0C, 0x02,
    0xFF
};

const uint8 d_098A[] = {
    0x02, 0x00, 0x03, 0x70, 0x02, 0x0C, 0x01, 0x70, 0x01, 0x71, 0x01, 0x73, 0x01, 0x75, 0x03, 0x0C, 0x02, 0xFF
};

const uint8 d_099C[] = {
    0x01, 0x00, 0x04, 0x78, 0x01, 0x7A, 0x01, 0x63, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x63, 0x01, 0x65, 0x03, 0xFF
};

const uint8 d_09AE[] = {
    0x01, 0x00, 0x05, 0x73, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x73, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x60, 0x03, 0xFF
};

const uint8 d_09C0[] = {
    0x01, 0x00, 0x07, 0x8A, 0x01, 0x73, 0x01, 0x78, 0x01, 0x8A, 0x01, 0x73, 0x01, 0x78, 0x01, 0x7A, 0x03, 0xFF
};

const uint8 d_09D2[] = {
    0x01, 0x06, 0x04, 0x7A, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x61, 0x01, 0x65, 0x01, 0x68, 0x03, 0xFF
};

const uint8 d_09E2[] = {
    0x01, 0x06, 0x04, 0x78, 0x01, 0x75, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x61, 0x01, 0x65, 0x03, 0xFF
};

const uint8 d_09F2[] = {
    0x01, 0x06, 0x04, 0x75, 0x01, 0x71, 0x01, 0x75, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x60, 0x03, 0xFF
};

const uint8 d_0A02[] = {
    0x02, 0x04, 0x03, 0x7A, 0x01, 0x76, 0x01, 0x78, 0x01, 0x75, 0x01, 0x76, 0x01, 0x73, 0x01, 0x75, 0x01, 0x72, 0x01, 0x73, 0x01, 0x8A, 0x01,
    0x8B, 0x01, 0x88, 0x01, 0x86, 0x01, 0x85, 0x01, 0x83, 0x01, 0x82, 0x01, 0x83, 0x01, 0x86, 0x01,
    0x85, 0x01, 0x88, 0x01, 0x86, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x8B, 0x01, 0x8A, 0x01, 0x73, 0x01,
    0x72, 0x01, 0x73, 0x01, 0x75, 0x01, 0x8A, 0x01, 0x70, 0x01, 0x72, 0x01, 0xFF
};

const uint8 d_0A46[] = {
    0x02, 0x04, 0x03, 0x76, 0x01, 0x73, 0x01, 0x75, 0x01, 0x72, 0x01, 0x73, 0x01, 0x70, 0x01, 0x72, 0x01, 0x8A, 0x01,
    0x8B, 0x01, 0x86, 0x01, 0x88, 0x01, 0x85, 0x01, 0x83, 0x01, 0x82, 0x01, 0x80, 0x01, 0x9A, 0x01,
    0x9A, 0x01, 0x83, 0x01, 0x82, 0x01, 0x85, 0x01, 0x83, 0x01, 0x86, 0x01, 0x85, 0x01, 0x88, 0x01,
    0x86, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x8B, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x86, 0x01, 0x85, 0x01,
    0xFF
};

const uint8 d_0A8A[] = {
    0x02, 0x10, 0x03, 0x93, 0x02, 0x9A, 0x02, 0x83, 0x03, 0x9A, 0x01, 0x98, 0x01, 0x96, 0x01,
    0x95, 0x01, 0x93, 0x02, 0x95, 0x03, 0x96, 0x02, 0x98, 0x02, 0x9A, 0x02, 0x9B, 0x02, 0x9A, 0x02,
    0x98, 0x01, 0x96, 0x01, 0x95, 0x01, 0x92, 0x01, 0x93, 0x01, 0x95, 0x01, 0xFF
};

const uint8 d_0AB6[] = {
    0x02, 0x04, 0x03, 0x7A, 0x01, 0x77, 0x01, 0x78, 0x01, 0x75, 0x01, 0x77, 0x01, 0x73, 0x01, 0x75, 0x01, 0x72, 0x01,
    0x73, 0x01, 0x8A, 0x01, 0x80, 0x01, 0x88, 0x01, 0x87, 0x01, 0x85, 0x01, 0x83, 0x01, 0x82, 0x01,
    0x83, 0x01, 0x87, 0x01, 0x85, 0x01, 0x88, 0x01, 0x87, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x80, 0x01,
    0x8A, 0x01, 0x73, 0x01, 0x72, 0x01, 0x73, 0x01, 0x75, 0x01, 0x8A, 0x01, 0x70, 0x01, 0x72, 0x01,
    0xFF
};

const uint8 d_0AFA[] = {
    0x02, 0x04, 0x03, 0x77, 0x01, 0x73, 0x01, 0x75, 0x01, 0x72, 0x01, 0x73, 0x01, 0x70, 0x01,
    0x72, 0x01, 0x8A, 0x01, 0x80, 0x01, 0x87, 0x01, 0x88, 0x01, 0x85, 0x01, 0x83, 0x01, 0x82, 0x01,
    0x80, 0x01, 0x9A, 0x01, 0x9A, 0x01, 0x83, 0x01, 0x82, 0x01, 0x85, 0x01, 0x83, 0x01, 0x87, 0x01,
    0x85, 0x01, 0x88, 0x01, 0x87, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x80, 0x01, 0x8A, 0x01, 0x88, 0x01,
    0x87, 0x01, 0x85, 0x01, 0xFF
};

const uint8 d_0B3E[] = {
    0x02, 0x10, 0x03, 0x93, 0x02, 0x9A, 0x02, 0x83, 0x03, 0x9A, 0x01,
    0x98, 0x01, 0x97, 0x01, 0x95, 0x01, 0x93, 0x02, 0x95, 0x03, 0x97, 0x02, 0x98, 0x02, 0x9A, 0x02,
    0x90, 0x02, 0x9A, 0x02, 0x98, 0x01, 0x97, 0x01, 0x95, 0x01, 0x92, 0x01, 0x93, 0x01, 0x95, 0x01,
    0xFF
};

const uint8 d_0B6A[] = {
    0x02, 0x04, 0x03, 0x7A, 0x01, 0x76, 0x01, 0x78, 0x01, 0x75, 0x01, 0x76, 0x01, 0x73, 0x01,
    0x75, 0x01, 0x72, 0x01, 0x73, 0x01, 0x8A, 0x01, 0x8A, 0x01, 0x88, 0x01, 0x86, 0x01, 0x85, 0x01,
    0x83, 0x01, 0x82, 0x01, 0x83, 0x01, 0x85, 0x01, 0x86, 0x01, 0x88, 0x01, 0x86, 0x01, 0x8A, 0x01,
    0x70, 0x01, 0x72, 0x01, 0x73, 0x04, 0xFF
};

const uint8 d_0BA0[] = {
    0x02, 0x04, 0x03, 0x76, 0x01, 0x73, 0x01, 0x75, 0x01,
    0x72, 0x01, 0x73, 0x01, 0x70, 0x01, 0x72, 0x01, 0x8A, 0x01, 0x8A, 0x01, 0x86, 0x01, 0x86, 0x01,
    0x85, 0x01, 0x83, 0x01, 0x82, 0x01, 0x80, 0x01, 0x9A, 0x01, 0x9A, 0x01, 0x8B, 0x01, 0x80, 0x01,
    0x82, 0x01, 0x83, 0x01, 0x85, 0x01, 0x86, 0x01, 0x88, 0x01, 0x8A, 0x04, 0xFF
};

const uint8 d_0BD6[] = {
    0x02, 0x10, 0x03, 0x73, 0x02, 0x75, 0x02, 0x76, 0x02, 0x75, 0x02, 0x73, 0x02, 0x72, 0x02, 0x70, 0x02, 0x72, 0x02,
    0x73, 0x02, 0x8B, 0x02, 0x8A, 0x02, 0x86, 0x02, 0x83, 0x04, 0xFF
};

const uint8 d_0BF4[] = {
    0x00, 0x00, 0x04, 0x71, 0x04, 0x73, 0x04, 0x71, 0x04, 0x73, 0x04, 0x76, 0x04, 0x78, 0x04, 0x76, 0x04, 0x78, 0x04, 0xFF
};

const uint8 d_0C08[] = {
    0x00, 0x00, 0x06, 0x56, 0x01, 0x55, 0x01, 0x54, 0x01, 0x53, 0x01, 0x52, 0x01, 0x51, 0x01, 0x50, 0x01,
    0x6B, 0x01, 0x6A, 0x01, 0x69, 0x01, 0x68, 0x01, 0x67, 0x01, 0x66, 0x01, 0x65, 0x01, 0x64, 0x01,
    0x63, 0x01, 0x62, 0x01, 0x61, 0x01, 0x60, 0x01, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0x01, 0x78, 0x01,
    0x77, 0x01, 0x76, 0x01, 0x75, 0x01, 0x74, 0x01, 0x73, 0x01, 0x72, 0x01, 0x71, 0x01, 0x70, 0x01,
    0x8B, 0x01, 0x8A, 0x01, 0x89, 0x01, 0x88, 0x01, 0x87, 0x01, 0x86, 0x01, 0x85, 0x01, 0x84, 0x01,
    0x83, 0x01, 0xFF
};

const uint8 d_0C5C[] = {
    0x02, 0x04, 0x05, 0x60, 0x01, 0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01,
    0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01, 0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01,
    0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01, 0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01,
    0x78, 0x01, 0x75, 0x01, 0x71, 0x01, 0x60, 0x01, 0x0C, 0x01, 0x78, 0x01, 0x7A, 0x01, 0x75, 0x01,
    0x78, 0x01, 0x73, 0x01, 0x75, 0x01, 0x61, 0x01, 0x7A, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01,
    0x7A, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01, 0x7A, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01,
    0x7A, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01, 0x79, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01,
    0x79, 0x01, 0x76, 0x01, 0x73, 0x01, 0x61, 0x01, 0x0C, 0x01, 0x79, 0x01, 0x61, 0x01, 0x78, 0x01,
    0x79, 0x01, 0x75, 0x01, 0x78, 0x01, 0xFF
};

const uint8 d_0CE0[] = {
    0x02, 0x02, 0x05, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0xFF
};

const uint8 d_0CEA[] = {
    0x02, 0x04, 0x05, 0x61, 0x02, 0x78, 0x02, 0x78, 0x02, 0x61, 0x02, 0x78, 0x02, 0x78, 0x02,
    0x61, 0x02, 0x78, 0x02, 0x78, 0x02, 0x61, 0x02, 0x78, 0x02, 0x78, 0x02, 0x61, 0x02, 0x78, 0x02,
    0x7A, 0x02, 0x75, 0x02, 0x63, 0x02, 0x7A, 0x02, 0x7A, 0x02, 0x63, 0x02, 0x7A, 0x02, 0x7A, 0x02,
    0x63, 0x02, 0x7A, 0x02, 0x79, 0x02, 0x63, 0x02, 0x79, 0x02, 0x79, 0x02, 0x63, 0x02, 0x79, 0x02,
    0x76, 0x02, 0x73, 0x02, 0xFF
};

const uint8 d_0D2E[] = {
    0x02, 0x02, 0x05, 0x78, 0x01, 0x78, 0x01, 0x78, 0x01, 0xFF
};

const uint8 d_0D38[] = {
    0x02, 0x10, 0x05, 0x85, 0x06, 0x85, 0x06, 0x85, 0x06, 0x85, 0x06, 0x85, 0x04, 0x85, 0x04, 0x86, 0x06,
    0x86, 0x06, 0x86, 0x06, 0x86, 0x06, 0x86, 0x04, 0x86, 0x04, 0xFF
};

const uint8 d_0D54[] = {
    0x02, 0x04, 0x05, 0x81, 0x01, 0x81, 0x01, 0x81, 0x01, 0xFF
};

const uint8 d_0D5E[] = {
    0x02, 0x00, 0x07, 0x65, 0x01, 0x0C, 0x01, 0x61, 0x01, 0x0C, 0x01, 0x63, 0x01, 0xFF
};

const uint8 d_0D6C[] = {
    0x02, 0x00, 0x05, 0x7A, 0x05, 0x0C, 0x01, 0x7A, 0x01, 0x0C, 0x01, 0x7A, 0x03,
    0x0C, 0x01, 0x78, 0x07, 0x0C, 0x01, 0x78, 0x07, 0x0C, 0x01, 0x78, 0x03, 0x0C, 0x01, 0x7B, 0x05,
    0x0C, 0x01, 0x7B, 0x01, 0x0C, 0x01, 0x7B, 0x03, 0x0C, 0x01, 0x7A, 0x07, 0x0C, 0x01, 0x7A, 0x07,
    0x0C, 0x01, 0x7A, 0x03, 0x0C, 0x01, 0x7B, 0x01, 0x0C, 0x01, 0x7B, 0x01, 0x0C, 0x03, 0x7B, 0x01,
    0x0C, 0x01, 0x7B, 0x03, 0x0C, 0x01, 0x61, 0x01, 0x0C, 0x01, 0x61, 0x01, 0x0C, 0x03, 0x61, 0x01,
    0x0C, 0x01, 0x61, 0x03, 0x0C, 0x01, 0x61, 0x03, 0x0C, 0x01, 0x61, 0x03, 0x0C, 0x01, 0x63, 0x01,
    0x0C, 0x01, 0x63, 0x01, 0x0C, 0x03, 0x63, 0x01, 0x0C, 0x01, 0x63, 0x03, 0x0C, 0x01, 0x63, 0x03,
    0x0C, 0x01, 0x63, 0x03, 0x0C, 0x01, 0xFF
};

const uint8 d_0DE0[] = {
    0x02, 0x00, 0x03, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02,
    0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02, 0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02,
    0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02, 0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02,
    0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02, 0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02,
    0x76, 0x02, 0x86, 0x02, 0x8A, 0x02, 0x71, 0x02, 0x76, 0x02, 0x77, 0x01, 0x0C, 0x01, 0x77, 0x01,
    0x0C, 0x03, 0x77, 0x01, 0x0C, 0x01, 0x77, 0x03, 0x0C, 0x01, 0x69, 0x01, 0x0C, 0x01, 0x69, 0x01,
    0x0C, 0x03, 0x69, 0x01, 0x0C, 0x01, 0x69, 0x03, 0x0C, 0x01, 0x69, 0x03, 0x0C, 0x01, 0x69, 0x03,
    0x0C, 0x01, 0x8B, 0x02, 0x73, 0x02, 0x76, 0x02, 0x7B, 0x02, 0x7B, 0x02, 0x76, 0x02, 0x73, 0x02,
    0x8B, 0x02, 0xFF
};

const uint8 d_0E5C[] = {
    0x00, 0x00, 0x02, 0x86, 0x08, 0x81, 0x08, 0x86, 0x08, 0x81, 0x08, 0x86, 0x08,
    0x81, 0x08, 0x86, 0x08, 0x81, 0x08, 0x82, 0x01, 0x0C, 0x01, 0x82, 0x01, 0x0C, 0x03, 0x82, 0x01,
    0x0C, 0x01, 0x82, 0x03, 0x0C, 0x01, 0x84, 0x01, 0x0C, 0x01, 0x84, 0x01, 0x0C, 0x03, 0x84, 0x01,
    0x0C, 0x01, 0x84, 0x03, 0x0C, 0x01, 0x84, 0x03, 0x0C, 0x01, 0x84, 0x03, 0x0C, 0x01, 0x7B, 0x08,
    0x76, 0x04, 0x8B, 0x04, 0xFF
};

const uint8 d_0E9E[] = {
    0x00, 0x0C, 0x05, 0x75, 0x0C, 0x71, 0x0C, 0x8A, 0x0C, 0x86, 0x0C,
    0x0C, 0x09, 0x75, 0x03, 0x71, 0x09, 0x8A, 0x03, 0x86, 0x04, 0x8A, 0x04, 0x71, 0x04, 0x89, 0x04,
    0x70, 0x04, 0x73, 0x04, 0x8B, 0x0C, 0x73, 0x0C, 0x76, 0x0C, 0x78, 0x0C, 0x0C, 0x09, 0x79, 0x03,
    0x76, 0x09, 0x72, 0x03, 0x8B, 0x04, 0x89, 0x04, 0x86, 0x04, 0x72, 0x04, 0x89, 0x04, 0x76, 0x04, 0xFF
};

const uint8 d_0EDA[] = {
    0x00, 0x0C, 0x05, 0x71, 0x0C, 0x8A, 0x0C, 0x86, 0x0C, 0x85, 0x0C, 0x0C, 0x09, 0x81, 0x03,
    0x8A, 0x09, 0x86, 0x03, 0x85, 0x04, 0x86, 0x04, 0x8A, 0x04, 0x86, 0x04, 0x89, 0x04, 0x8B, 0x04,
    0x88, 0x0C, 0x8B, 0x0C, 0x73, 0x0C, 0x76, 0x0C, 0x0C, 0x09, 0x76, 0x03, 0x72, 0x09, 0x8B, 0x03,
    0x8A, 0x04, 0x86, 0x04, 0x82, 0x04, 0x8B, 0x04, 0x89, 0x04, 0x82, 0x04, 0xFF
};

const uint8 d_0F16[] = {
    0x00, 0x00, 0x03, 0x75, 0x18, 0x75, 0x18, 0x75, 0x18, 0x71, 0x0C, 0x75, 0x0C, 0x73, 0x18, 0x73, 0x18, 0x72, 0x18,
    0x76, 0x0C, 0x78, 0x0C, 0xFF
};
