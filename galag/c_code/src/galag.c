/*******************************************************************************
 **  galag: precise re-implementation of a popular space shoot-em-up
 **  galag.c
 **    This is a hodgepodge of stuff that allows the game to follow the
 **    structure of the 8-bit assembly code as closely as possible in a PC
 **    environment. The parts of MAME that are used are only to provide
 **    services for timing, graphics and sound that would be provided by the
 **    real machine and not implemented in the game code.
 *******************************************************************************/
/*
 ** header file includes
 */
#include "uclock.h" // src/Win32
#include "driver.h" // references to MAME code

#include "galag.h"

/*
 ** static external definitions in this file
 */

// local copy of pointer to MAME machine info
static struct MachineDriver *sim_drv;

/*
 ** non-static external definitions this file or others
 */

// globals
uint8 irq_acknowledge_enable_cpu0;
uint8 irq_acknowledge_enable_cpu1;
uint8 nmi_acknowledge_enable_cpu2;


/***************************************************************************
This is a kludge to simulate interfacing with external IO chip to trigger
an explosion sound which is generated by the MAME supported functions.
 ***************************************************************************/
void c_io_cmd_wait(void)
{
    //    struct RunningMachine *Machine = pMachine ;
#if 0 // TODO: function call has changed
    if (Machine->samples->sample[0])
        osd_play_sample(7, (unsigned char *)Machine->samples->sample[0]->data,
                        Machine->samples->sample[0]->length,
                        Machine->samples->sample[0]->smpfreq,
                        Machine->samples->sample[0]->volume, 0);
#endif // XMAME
}

/***************************************************************************

  Simulate periodic tasks triggered on interrupts for all 3 CPUs

 ***************************************************************************/
static void vblank_work(void)
{
    // Execute the "CPU0" Vblank interrupt (RST38).
    if (0 != irq_acknowledge_enable_cpu0) // rst38 enabled in cpu0_post
    {
        cpu0_rst38();
    }

    // Execute the other sub-CPU's if they are enabled.

    // "CPU1" has a Vblank interrupt (RST38).

    // galaga_halt_w
    if (0 != irq_acknowledge_enable_cpu1) // rst38 enabled in cpu1_init
    {
        cpu1_rst38();
    }

    // CPU2 has 2 interrupts per frame (NMI)
    if (0 != nmi_acknowledge_enable_cpu2) // NMI enabled cpu2_init
    {
        cpu2_NMI();
        cpu2_NMI();
    }
}

/***************************************************************************

  This function takes care of refreshing the screen, processing user input,
  and throttling the emulation speed to obtain the required frames per second.

  IN: blocking (no longer used)
        1 == blocking, i.e. read keys, doesn't return until vblank complete.
        0 == non-blocking, i.e. read keys but return if not vblank

 ***************************************************************************/
int _updatescreen(int blocking)
{
    static uclock_t prev;

    static int this1, last1;
    static int this2, last2;
    static int this3, last3;
    static int thisct, lastct;


    thisct = code_pressed(KEYCODE_LCONTROL);

    if (thisct && lastct != thisct)
    {
        io_input[1] &= ~0x10; // see note for f_1F04
    }
    else
    {
        io_input[1] |= 0x10; // see note for f_1F04
    }
    lastct = thisct;

    if ( code_pressed(KEYCODE_RIGHT) )
    {
        io_input[1] &= ~2;
    }
    else
    {
        io_input[1] |= 2;
    }

    if ( code_pressed(KEYCODE_LEFT) )
    {
        io_input[1] &= ~8;
    }
    else
    {
        io_input[1] |= 8;
    }


    /* if the user pressed ESC, stop the emulation */
    if ( code_pressed(KEYCODE_ESC) ) return 1;

    // get keys for coin-in switch and start button, which need to be debounced

    this3 = code_pressed(KEYCODE_3);
    if (this3 && last3 != this3)
    {
        if (io_input[0] < 255)
        {
            io_input[0]++;
        }
    }
    last3 = this3;

    this1 = code_pressed(KEYCODE_1);
    if (this1 && last1 != this1)
    {
        if (io_input[0] > 0)
        {
            io_input[0]--;
        }
    }
    last1 = this1;

    this2 = code_pressed(KEYCODE_2);
    if (this2 && last2 != this2)
    {
        if (io_input[0] > 0)
        {
            io_input[0] -= 2;
        }
    }
    last2 = this2;


    if (1)
    {
        uclock_t curr;

        updatescreen();

        /* now wait until it's time to trigger the interrupt */
        do
        {
            curr = uclock();
        }
        while (curr - prev < UCLOCKS_PER_SEC / sim_drv->frames_per_second);

        vblank_work();
        prev = curr;
    }

    return 0;
}

/***************************************************************************

  Entry point for game executive.
  Take care of any initialization needed for the platform
  prior to jumping into "Background task" of CPU0 in g_main.
  CPU1 and CPU2 background tasks are empty inf loops and don't need simulated.
  Interrupt processing for all 3 CPU processes happens during update function
  called during busy loops in CPU0 background task. Triggering of "ISRs" is
  sychronized to simulated 60hz time reference. Premise is that a "modern" CPU
  will take very little time to process all the code in the background task, so
  most time will be spent in the update, waiting for 1/60th-second to expire.
 ***************************************************************************/
void sim_run(struct MachineDriver *drv)
{
    int mstate = 1;

    sim_drv = drv;

    cpu0_init();
    cpu1_init();
    cpu2_init();

    cpu0_post();

    g_init();

    do
    {
        mstate = g_main();
    } while(mstate);
}
